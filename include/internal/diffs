30,31c30,31
<    template<class dynamic_bitvector_t>
<    class wt_string{
---
> template<class dynamic_bitvector_t>
> class wt_string{
33c33
<    public:
---
> public:
35,36c35,36
<       //we allow any alphabet
<       typedef uint64_t char_type;
---
> 	//we allow any alphabet
> 	typedef uint64_t char_type;
38,44c38,44
<       /*
<        * Constructor #1
<        *
<        * Alphabet is unknown. Characters are gamma-coded
<        *
<        */
<       wt_string(){}
---
> 	/*
> 	 * Constructor #1
> 	 *
> 	 * Alphabet is unknown. Characters are gamma-coded
> 	 *
> 	 */
> 	wt_string(){}
46,53c46,53
<       /*
<        * Constructor #2
<        *
<        * We know only alphabet size. Each character is assigned log2(sigma) bits.
<        * Characters are assigned codes 0,1,2,... in order of appearance
<        *
<        */
<       wt_string(uint64_t sigma){
---
> 	/*
> 	 * Constructor #2
> 	 *
> 	 * We know only alphabet size. Each character is assigned log2(sigma) bits.
> 	 * Characters are assigned codes 0,1,2,... in order of appearance
> 	 *
> 	 */
> 	wt_string(uint64_t sigma){
55,56c55,56
< 	 assert(sigma>0);
< 	 ae = alphabet_encoder(sigma);
---
> 		assert(sigma>0);
> 		ae = alphabet_encoder(sigma);
58c58
<       }
---
> 	}
60,68c60,68
<       /*
<        * Constructor #3
<        *
<        * We know character probabilities. Input: pairs <character, probability>
<        *
<        * Here the alphabet is Huffman encoded.
<        *
<        */
<       wt_string(vector<pair<char_type,double> >& P){
---
> 	/*
> 	 * Constructor #3
> 	 *
> 	 * We know character probabilities. Input: pairs <character, probability>
> 	 *
> 	 * Here the alphabet is Huffman encoded.
> 	 *
> 	 */
> 	wt_string(vector<pair<char_type,double> >& P){
70c70
< 	 ae = alphabet_encoder(P);
---
> 		ae = alphabet_encoder(P);
72c72
<       }
---
> 	}
74,77c74,77
<       /*
<        * number of bits in the bitvector
<        */
<       uint64_t size(){
---
> 	/*
> 	 * number of bits in the bitvector
> 	 */
> 	uint64_t size(){
79c79
< 	 return n;
---
> 		return n;
81c81
<       }
---
> 	}
83,86c83,86
<       /*
<        * high-level access to the string. Supports assign (operator=) and access
<        */
<       char_type operator[](uint64_t i){
---
> 	/*
> 	 * high-level access to the string. Supports assign (operator=) and access
> 	 */
> 	char_type operator[](uint64_t i){
88c88
< 	 return at(i);
---
> 		return at(i);
90c90
<       }
---
> 	}
92,95c92,95
<       /*
<        * access
<        */
<       char_type at(uint64_t i){
---
> 	/*
> 	 * access
> 	 */
> 	char_type at(uint64_t i){
97,98c97,98
< 	 assert(i<size());
< 	 return root.at(i);
---
> 		assert(i<size());
> 		return root.at(i);
100c100
<       }
---
> 	}
102,105c102,105
<       /*
<        * position of i-th character equal to c. 0 =< i < rank(size(),c)
<        */
<       uint64_t select(uint64_t i,char_type c){
---
> 	/*
> 	 * position of i-th character equal to c. 0 =< i < rank(size(),c)
> 	 */
> 	uint64_t select(uint64_t i,char_type c){
107,108c107,108
< 	 assert(ae.char_exists(c));
< 	 assert(i<rank(size(),c));
---
> 		assert(ae.char_exists(c));
> 		assert(i<rank(size(),c));
110c110
< 	 auto code = ae.encode(c);
---
> 		auto code = ae.encode(c);
112,115c112,115
< 	 //if this fails, it means that c is not present
< 	 //in the string or that it is not present
< 	 //in the initial dictionary (if any)
< 	 assert(code.size()>0);
---
> 		//if this fails, it means that c is not present
> 		//in the string or that it is not present
> 		//in the initial dictionary (if any)
> 		assert(code.size()>0);
117,118c117,118
< 	 //this code must have been inserted in the tree already
< 	 assert(root.exists(code));
---
> 		//this code must have been inserted in the tree already
> 		assert(root.exists(code));
120c120
< 	 return root.select(i,code);
---
> 		return root.select(i,code);
122c122
<       }
---
> 	}
124,127c124,127
<       /*
<        * number of chars equal to c before position i EXCLUDED
<        */
<       uint64_t rank(uint64_t i, char_type c){
---
> 	/*
> 	 * number of chars equal to c before position i EXCLUDED
> 	 */
> 	uint64_t rank(uint64_t i, char_type c){
129c129
< 	 assert(i<=size());
---
> 		assert(i<=size());
131c131
< 	 if(not ae.char_exists(c)) return 0;
---
> 		if(not ae.char_exists(c)) return 0;
133c133
< 	 auto code = ae.encode(c);
---
> 		auto code = ae.encode(c);
135,138c135,138
< 	 //if this fails, it means that c is not present
< 	 //in the string or that it is not present
< 	 //in the initial dictionary (if any)
< 	 assert(code.size()>0);
---
> 		//if this fails, it means that c is not present
> 		//in the string or that it is not present
> 		//in the initial dictionary (if any)
> 		assert(code.size()>0);
140,145c140,145
< 	 /*
< 	  * if condition is false, it means that the code is in the
< 	  * alphabet encoder, but it has not yet been inserted
< 	  * in the tree
< 	  */
< 	 return root.exists(code) ? root.rank(i,code) : 0;
---
> 		/*
> 		 * if condition is false, it means that the code is in the
> 		 * alphabet encoder, but it has not yet been inserted
> 		 * in the tree
> 		 */
> 		return root.exists(code) ? root.rank(i,code) : 0;
147c147
<       }
---
> 	}
149c149
<       bool char_exists(char_type c){
---
> 	bool char_exists(char_type c){
151c151
< 	 return ae.char_exists(c);
---
> 		return ae.char_exists(c);
153c153
<       }
---
> 	}
155c155
<       void push_back(char_type c){
---
> 	void push_back(char_type c){
157c157
< 	 insert(size(),c);
---
> 		insert(size(),c);
159c159
<       }
---
> 	}
161c161
<       void push_front(char_type c){
---
> 	void push_front(char_type c){
163c163
< 	 insert(0,c);
---
> 		insert(0,c);
165c165
<       }
---
> 	}
167,170c167,170
<       /*
<        * insert a bit set at position i
<        */
<       void insert(uint64_t i, char_type c){
---
> 	/*
> 	 * insert a bit set at position i
> 	 */
> 	void insert(uint64_t i, char_type c){
172,174c172,174
< 	 //get code of c
< 	 //if code does not yet exist, create it
< 	 auto code = ae.encode(c);
---
> 		//get code of c
> 		//if code does not yet exist, create it
> 		auto code = ae.encode(c);
176c176
< 	 root.insert(i,code,c);
---
> 		root.insert(i,code,c);
178c178
< 	 n++;
---
> 		n++;
180c180
<       }
---
> 	}
182c182
<       uint64_t bit_size(){
---
> 	uint64_t bit_size(){
184c184
< 	 return sizeof(wt_string<dynamic_bitvector_t>)*8 + ae.bit_size() + root.bit_size();
---
> 		return sizeof(wt_string<dynamic_bitvector_t>)*8 + ae.bit_size() + root.bit_size();
186c186
<       }
---
> 	}
188c188
<       ulint alphabet_size(){
---
> 	ulint alphabet_size(){
190c190
< 	 return ae.size();
---
> 		return ae.size();
192c192
<       }
---
> 	}
194c194
<       ulint serialize(ostream &out){
---
> 	ulint serialize(ostream &out){
196c196
< 	 ulint w_bytes=0;
---
> 		ulint w_bytes=0;
198,199c198,199
< 	 out.write((char*)&n,sizeof(n));
< 	 w_bytes += sizeof(n);
---
> 		out.write((char*)&n,sizeof(n));
> 		w_bytes += sizeof(n);
201c201
< 	 w_bytes += root.serialize(out);
---
> 		w_bytes += root.serialize(out);
203c203
< 	 w_bytes += ae.serialize(out);
---
> 		w_bytes += ae.serialize(out);
205c205
< 	 return w_bytes;
---
> 		return w_bytes;
207c207
<       }
---
> 	}
209c209
<       void load(istream &in){
---
> 	void load(istream &in){
211,213c211,213
< 	 in.read((char*)&n,sizeof(n));
< 	 root.load(in);
< 	 ae.load(in);
---
> 		in.read((char*)&n,sizeof(n));
> 		root.load(in);
> 		ae.load(in);
215c215
<       }
---
> 	}
217c217
<    private:
---
> private:
219c219
<       class node{
---
> 	class node{
221c221
<       public:
---
> 	public:
223,224c223,224
< 	 //root constructor
< 	 node(){}
---
> 		//root constructor
> 		node(){}
226,227c226,227
< 	 //parent constructor
< 	 node(node* parent_){
---
> 		//parent constructor
> 		node(node* parent_){
229c229
< 	    this->parent_ = parent_;
---
> 			this->parent_ = parent_;
231c231
< 	 }
---
> 		}
233c233
< 	 ~node(){
---
> 		~node(){
235c235
< 	    if(has_child0()){
---
> 			if(has_child0()){
237,238c237,238
< 	       delete child0_;
< 	       child0_=NULL;
---
> 				delete child0_;
> 				child0_=NULL;
240c240
< 	    }
---
> 			}
242c242
< 	    if(has_child1()){
---
> 			if(has_child1()){
244,245c244,245
< 	       delete child1_;
< 	       child1_=NULL;
---
> 				delete child1_;
> 				child1_=NULL;
247c247
< 	    }
---
> 			}
249c249
< 	 }
---
> 		}
251,252c251,252
< 	 //turn this node into a leaf
< 	 void make_leaf(char_type c){
---
> 		//turn this node into a leaf
> 		void make_leaf(char_type c){
254,256c254,256
< 	    assert(not has_child0()); //musttnot have children
< 	    assert(not has_child1());
< 	    assert(bv.size()==0);
---
> 			assert(not has_child0()); //musttnot have children
> 			assert(not has_child1());
> 			assert(bv.size()==0);
258c258
< 	    assert(not is_root()); //cannot make the root leaf
---
> 			assert(not is_root()); //cannot make the root leaf
260,261c260,261
< 	    this->is_leaf_ = true;
< 	    this->l_=c;
---
> 			this->is_leaf_ = true;
> 			this->l_=c;
263c263
< 	 }
---
> 		}
265,266c265,266
< 	 //descend tree and return character at this position
< 	 char_type at(ulint i){
---
> 		//descend tree and return character at this position
> 		char_type at(ulint i){
268c268
< 	    if(is_leaf()) return label();
---
> 			if(is_leaf()) return label();
270c270
< 	    assert(i<bv.size());
---
> 			assert(i<bv.size());
272c272
< 	    bool b = bv[i];
---
> 			bool b = bv[i];
274c274
< 	    assert((b or has_child0()) and (not b or has_child1()));
---
> 			assert((b or has_child0()) and (not b or has_child1()));
276c276
< 	    if(b){
---
> 			if(b){
278c278
< 	       return child1_->at( bv.rank1(i) );
---
> 				return child1_->at( bv.rank1(i) );
280c280
< 	    }
---
> 			}
282c282
< 	    return child0_->at( bv.rank0(i) );
---
> 			return child0_->at( bv.rank0(i) );
284c284
< 	 }
---
> 		}
286,289c286,289
< 	 /*
< 	  * true iif code B has already been inserted
< 	  */
< 	 bool exists(vector<bool>& B, ulint j=0){
---
> 		/*
> 		 * true iif code B has already been inserted
> 		 */
> 		bool exists(vector<bool>& B, ulint j=0){
291c291
< 	    assert(j <= B.size());
---
> 			assert(j <= B.size());
293,294c293,294
< 	    //not at the end of B -> (B[j] -> must have child 1)
< 	    bool c1 = j==B.size() || (not B[j] || has_child1());
---
> 			//not at the end of B -> (B[j] -> must have child 1)
> 			bool c1 = j==B.size() || (not B[j] || has_child1());
296,297c296,297
< 	    //not at the end of B -> (notB[j] -> must have child 0)
< 	    bool c0 = j==B.size() || (B[j] || has_child0());
---
> 			//not at the end of B -> (notB[j] -> must have child 0)
> 			bool c0 = j==B.size() || (B[j] || has_child0());
299,308c299,308
< 	    return  (c1 and c0) &&
< 	       (
< 		j==B.size() ?
< 		true :
< 		(
< 		 B[j] ?
< 		 child1_->exists( B, j+1 ):
< 		 child0_->exists( B, j+1 )
< 		 )
< 		);
---
> 			return  (c1 and c0) &&
> 					(
> 						j==B.size() ?
> 						true :
> 						(
> 								B[j] ?
> 								child1_->exists( B, j+1 ):
> 								child0_->exists( B, j+1 )
> 						)
> 					);
310c310
< 	 }
---
> 		}
312,316c312,316
< 	 /*
< 	  * insert code B[j,...,B.size()-1] at position i. This code is associated
< 	  * with character c
< 	  */
< 	 void insert(ulint i, vector<bool>& B, char_type c, ulint j=0){
---
> 		/*
> 		 * insert code B[j,...,B.size()-1] at position i. This code is associated
> 		 * with character c
> 		 */
> 		void insert(ulint i, vector<bool>& B, char_type c, ulint j=0){
318c318
< 	    if(j==B.size()){
---
> 			if(j==B.size()){
320,321c320,321
< 	       //this node must be a leaf
< 	       assert(bv.size()==0);
---
> 				//this node must be a leaf
> 				assert(bv.size()==0);
323c323
< 	       if(is_leaf()){
---
> 				if(is_leaf()){
325,327c325,327
< 		  //if it's already marked as leaf, check
< 		  //that the label is correct
< 		  assert(c==label());
---
> 					//if it's already marked as leaf, check
> 					//that the label is correct
> 					assert(c==label());
329c329
< 	       }else{
---
> 				}else{
331,332c331,332
< 		  //else, mark node as leaf
< 		  make_leaf(c);
---
> 					//else, mark node as leaf
> 					make_leaf(c);
334c334
< 	       }
---
> 				}
336c336
< 	       return;
---
> 				return;
338c338
< 	    }
---
> 			}
340,341c340,341
< 	    assert(i<=bv.size());
< 	    assert(not is_leaf());
---
> 			assert(i<=bv.size());
> 			assert(not is_leaf());
343,344c343,344
< 	    bool b = B[j];
< 	    bv.insert(i,b);
---
> 			bool b = B[j];
> 			bv.insert(i,b);
346c346
< 	    if(b){
---
> 			if(b){
348,351c348,351
< 	       //if child does not exist, create it.
< 	       if(not has_child1()){
< 		  child1_ = new node(this);
< 	       }
---
> 				//if child does not exist, create it.
> 				if(not has_child1()){
> 					child1_ = new node(this);
> 				}
353c353
< 	       assert(j == B.size()-1 or bv.rank1(i) <= child1_->bv.size());
---
> 				assert(j == B.size()-1 or bv.rank1(i) <= child1_->bv.size());
355c355
< 	       child1_->insert( bv.rank1(i), B, c, j+1 );
---
> 				child1_->insert( bv.rank1(i), B, c, j+1 );
357c357
< 	    }else{
---
> 			}else{
359,361c359,361
< 	       if(not has_child0()){
< 		  child0_ = new node(this);
< 	       }
---
> 				if(not has_child0()){
> 					child0_ = new node(this);
> 				}
363c363
< 	       assert(j == B.size()-1 or  bv.rank0(i) <= child0_->bv.size());
---
> 				assert(j == B.size()-1 or  bv.rank0(i) <= child0_->bv.size());
365c365
< 	       child0_->insert( bv.rank0(i), B, c, j+1 );
---
> 				child0_->insert( bv.rank0(i), B, c, j+1 );
367c367
< 	    }
---
> 			}
369c369
< 	 }
---
> 		}
371,375c371
< 	 /*
< 	  * remove code B[j,...,B.size()-1] from position i. This code is associated
< 	  * with character c
< 	  */
< 	 void remove(ulint i, vector<bool>& B, char_type c, ulint j=0){
---
> 		ulint rank(ulint i, vector<bool>& B, ulint j=0){
377c373
< 	    if(j==B.size()){
---
> 			assert(j <= B.size());
379,384c375,376
< 	       //TODO: Check if leaf should be deleted?
< 	       
< 	       //this node must be a leaf
< 	       assert(bv.size()==0);
< 	       assert( c == label() );
< 	       // if(is_leaf()){
---
> 			//not at the end of B -> (B[j] -> must have child 1)
> 			assert(j==B.size() || (not B[j] || has_child1()));
386,388c378,379
< 	       // 	  //if it's already marked as leaf, check
< 	       // 	  //that the label is correct
< 	       // 	  assert(c==label());
---
> 			//not at the end of B -> (notB[j] -> must have child 0)
> 			assert(j==B.size() || (B[j] || has_child0()));
390c381,382
< 	       // }else{
---
> 			//not at the end of B -> i must be smaller than bv.size()
> 			assert(j==B.size() || i<=bv.size());
392,393c384,390
< 	       // 	  //else, mark node as leaf
< 	       // 	  make_leaf(c);
---
> 			return  j==B.size() ?
> 					i :
> 					(
> 							B[j] ?
> 							child1_->rank( bv.rank1(i), B, j+1 ):
> 							child0_->rank( bv.rank0(i), B, j+1 )
> 					);
395c392
< 	       // }
---
> 		}
397d393
< 	       return;
399c395
< 	    }
---
> 		ulint select(ulint i, vector<bool>& B){
401,402c397,398
< 	    assert(i<=(bv.size() - 1));
< 	    assert(not is_leaf());
---
> 			//top-down: find leaf associated with B
> 			node* L = get_leaf(B);
404c400
< 	    bool b = B[j];
---
> 			auto p = L->parent_;
406c402,403
< 	    assert(b == bv.at(i));
---
> 			//bottom-up: from leaf to root
> 			return p->select(i,B,B.size()-1);
408c405
< 	    if(b){
---
> 		}
410c407
< 	       //TODO: delete empty nodes?
---
> 		ulint select(ulint i, vector<bool>& B, ulint j){
412c409
< 	       assert(j == B.size()-1 or bv.rank1(i) <= child1_->bv.size());
---
> 			auto s = bv.select(i,B[j]);
414c411,413
< 	       child1_->remove( bv.rank1(i), B, c, j+1 );
---
> 			return 	j==0 ?
> 					s :
> 					parent_->select( s, B, j-1);
416c415
< 	    }else{
---
> 		}
418c417,418
< 	       assert(j == B.size()-1 or  bv.rank0(i) <= child0_->bv.size());
---
> 		//get leaf associated to code B
> 		node* get_leaf(vector<bool>& B, ulint j=0){
420c420
< 	       child0_->remove( bv.rank0(i), B, c, j+1 );
---
> 			assert(j<=B.size());
422c422,426
< 	    }
---
> 			return 	j==B.size() ? this :
> 					(
> 						B[j]?
> 						child1_->get_leaf(B,j+1) :
> 						child0_->get_leaf(B,j+1)
424,425c428
< 	    bv.remove(i);
< 	 }
---
> 					);
427c430
< 	 ulint rank(ulint i, vector<bool>& B, ulint j=0){
---
> 		}
429c432,435
< 	    assert(j <= B.size());
---
> 		bool is_root(){ return not parent_; }
> 		bool is_leaf(){ return is_leaf_; }
> 		bool has_child0(){ return child0_; }
> 		bool has_child1(){ return child1_; }
431,432c437,442
< 	    //not at the end of B -> (B[j] -> must have child 1)
< 	    assert(j==B.size() || (not B[j] || has_child1()));
---
> 		/*
> 		 * to have left label, this node must not have a left (0)
> 		 * child AND must have at least one bit equal to 0 in
> 		 * its bitvector
> 		 */
> 		char_type label(){
434,435c444,445
< 	    //not at the end of B -> (notB[j] -> must have child 0)
< 	    assert(j==B.size() || (B[j] || has_child0()));
---
> 			assert(is_leaf());
> 			return l_;
437,438c447
< 	    //not at the end of B -> i must be smaller than bv.size()
< 	    assert(j==B.size() || i<=bv.size());
---
> 		}
440,446c449,458
< 	    return  j==B.size() ?
< 	       i :
< 	       (
< 		B[j] ?
< 		child1_->rank( bv.rank1(i), B, j+1 ):
< 		child0_->rank( bv.rank0(i), B, j+1 )
< 		);
---
> 		/*
> 		 * Total number of bits allocated in RAM for this structure
> 		 *
> 		 * WARNING: this measure is good only for relatively small alphabets (e.g. ASCII)
> 		 * as we use STL containers such as set and map which do not give direct info on
> 		 * the total memory allocated. The sizes of these containers are proportional
> 		 * to the alphabet size (but the constants involved are high since internally
> 		 * they can use heavy structures as RBT)
> 		 */
> 		ulint bit_size(){
448c460
< 	 }
---
> 			ulint size = sizeof(node)*8;
449a462
> 			size += bv.bit_size();
451c464,465
< 	 ulint select(ulint i, vector<bool>& B){
---
> 			if(child0_ != NULL) size += child0_->bit_size();
> 			if(child1_ != NULL) size += child1_->bit_size();
453,454c467
< 	    //top-down: find leaf associated with B
< 	    node* L = get_leaf(B);
---
> 			return size;
456c469
< 	    auto p = L->parent_;
---
> 		}
458,459c471
< 	    //bottom-up: from leaf to root
< 	    return p->select(i,B,B.size()-1);
---
> 		ulint serialize(ostream &out){
461c473
< 	 }
---
> 			ulint w_bytes=0;
463c475,476
< 	 ulint select(ulint i, vector<bool>& B, ulint j){
---
> 			out.write((char*)&l_,sizeof(l_));
> 			w_bytes += sizeof(l_);
465c478,479
< 	    auto s = bv.select(i,B[j]);
---
> 			out.write((char*)&is_leaf_,sizeof(is_leaf_));
> 			w_bytes += sizeof(is_leaf_);
467,469c481
< 	    return 	j==0 ?
< 	       s :
< 	       parent_->select( s, B, j-1);
---
> 			w_bytes += bv.serialize(out);
471c483,484
< 	 }
---
> 			bool has_child0 = child0_ != NULL;
> 			bool has_child1 = child1_ != NULL;
473,474c486,487
< 	 //get leaf associated to code B
< 	 node* get_leaf(vector<bool>& B, ulint j=0){
---
> 			out.write((char*)&has_child0,sizeof(has_child0));
> 			w_bytes += sizeof(has_child0);
476c489,490
< 	    assert(j<=B.size());
---
> 			out.write((char*)&has_child1,sizeof(has_child1));
> 			w_bytes += sizeof(has_child1);
478,482c492,493
< 	    return 	j==B.size() ? this :
< 	       (
< 		B[j]?
< 		child1_->get_leaf(B,j+1) :
< 		child0_->get_leaf(B,j+1)
---
> 			if(child0_) w_bytes += child0_->serialize(out);
> 			if(child1_) w_bytes += child1_->serialize(out);
484c495
< 		);
---
> 			return w_bytes;
486c497
< 	 }
---
> 		}
488,491c499
< 	 bool is_root(){ return not parent_; }
< 	 bool is_leaf(){ return is_leaf_; }
< 	 bool has_child0(){ return child0_; }
< 	 bool has_child1(){ return child1_; }
---
> 		void load(istream &in){
493,498c501
< 	 /*
< 	  * to have left label, this node must not have a left (0)
< 	  * child AND must have at least one bit equal to 0 in
< 	  * its bitvector
< 	  */
< 	 char_type label(){
---
> 			in.read((char*)&l_,sizeof(l_));
500,501c503
< 	    assert(is_leaf());
< 	    return l_;
---
> 			in.read((char*)&is_leaf_,sizeof(is_leaf_));
503c505
< 	 }
---
> 			bv.load(in);
505,514c507,508
< 	 /*
< 	  * Total number of bits allocated in RAM for this structure
< 	  *
< 	  * WARNING: this measure is good only for relatively small alphabets (e.g. ASCII)
< 	  * as we use STL containers such as set and map which do not give direct info on
< 	  * the total memory allocated. The sizes of these containers are proportional
< 	  * to the alphabet size (but the constants involved are high since internally
< 	  * they can use heavy structures as RBT)
< 	  */
< 	 ulint bit_size(){
---
> 			bool has_child0;
> 			bool has_child1;
516c510,511
< 	    ulint size = sizeof(node)*8;
---
> 			in.read((char*)&has_child0,sizeof(has_child0));
> 			in.read((char*)&has_child1,sizeof(has_child1));
518c513,514
< 	    size += bv.bit_size();
---
> 			child0_ = NULL;
> 			child1_ = NULL;
520,521c516
< 	    if(child0_ != NULL) size += child0_->bit_size();
< 	    if(child1_ != NULL) size += child1_->bit_size();
---
> 			if(has_child0){
523c518,520
< 	    return size;
---
> 				child0_ = new node();
> 				child0_->load(in);
> 				child0_->parent_ = this;
525c522
< 	 }
---
> 			}
527c524
< 	 ulint serialize(ostream &out){
---
> 			if(has_child1){
529c526,528
< 	    ulint w_bytes=0;
---
> 				child1_ = new node();
> 				child1_->load(in);
> 				child1_->parent_ = this;
531,532c530
< 	    out.write((char*)&l_,sizeof(l_));
< 	    w_bytes += sizeof(l_);
---
> 			}
534,535c532
< 	    out.write((char*)&is_leaf_,sizeof(is_leaf_));
< 	    w_bytes += sizeof(is_leaf_);
---
> 		}
537c534
< 	    w_bytes += bv.serialize(out);
---
> 	private:
539,540c536,538
< 	    bool has_child0 = child0_ != NULL;
< 	    bool has_child1 = child1_ != NULL;
---
> 		node* child0_ = NULL;
> 		node* child1_ = NULL;
> 		node* parent_ = NULL;		//parent (NULL if root)
542,543c540
< 	    out.write((char*)&has_child0,sizeof(has_child0));
< 	    w_bytes += sizeof(has_child0);
---
> 		dynamic_bitvector_t bv;
545,546c542,544
< 	    out.write((char*)&has_child1,sizeof(has_child1));
< 	    w_bytes += sizeof(has_child1);
---
> 		//if is_leaf_, then node is labeled
> 		char_type l_ = 0;
> 		bool is_leaf_ = false;
548,549c546
< 	    if(child0_) w_bytes += child0_->serialize(out);
< 	    if(child1_) w_bytes += child1_->serialize(out);
---
> 	};
551c548,549
< 	    return w_bytes;
---
> 	//current length
> 	ulint n = 0;
553c551
< 	 }
---
> 	node root;
555c553
< 	 void load(istream &in){
---
> 	alphabet_encoder ae;
557,611c555
< 	    in.read((char*)&l_,sizeof(l_));
< 
< 	    in.read((char*)&is_leaf_,sizeof(is_leaf_));
< 
< 	    bv.load(in);
< 
< 	    bool has_child0;
< 	    bool has_child1;
< 
< 	    in.read((char*)&has_child0,sizeof(has_child0));
< 	    in.read((char*)&has_child1,sizeof(has_child1));
< 
< 	    child0_ = NULL;
< 	    child1_ = NULL;
< 
< 	    if(has_child0){
< 
< 	       child0_ = new node();
< 	       child0_->load(in);
< 	       child0_->parent_ = this;
< 
< 	    }
< 
< 	    if(has_child1){
< 
< 	       child1_ = new node();
< 	       child1_->load(in);
< 	       child1_->parent_ = this;
< 
< 	    }
< 
< 	 }
< 
<       private:
< 
< 	 node* child0_ = NULL;
< 	 node* child1_ = NULL;
< 	 node* parent_ = NULL;		//parent (NULL if root)
< 
< 	 dynamic_bitvector_t bv;
< 
< 	 //if is_leaf_, then node is labeled
< 	 char_type l_ = 0;
< 	 bool is_leaf_ = false;
< 
<       };
< 
<       //current length
<       ulint n = 0;
< 
<       node root;
< 
<       alphabet_encoder ae;
< 
<    };
---
> };
